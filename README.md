# Исследование

## Цель исследования
На примере конкреткой задачи научиться применять наборы алгоритмов.

Научиться искать объективную выборку тестов и сравнивать поведения алгоритмов на этой выборке.

## Задача

Есть трасса с двумя машинками, наборами флагов и препятствий. 
Есть строгий порядок сбора флагов, но не имеет значения, какая из машинок возьмет флаг.

Каждый ход машинка может изменить своё ускорение на (x,y) -1 ≤ x,y ≤ 1 или вызвать команду Exchange. 
Если обе машинки на текущем ходу вызвали команду Exchange, они обмениваются своими векторами скоростей.

На каждый ход машинкам даётся 100ms.
У команды Exchange есть cooldown – 20 ходов.

## Выбранные алгоритмы
Все подходы используют эмуляцию на несколько шагов вперед и оценивают решение одной из функций оценок, представленных в классе `Emulator`. В частности, по результатам тестрирования была выбрана функция `GetScore_3`.

### Жадный поиск (`GreedySolver`)
Классический жадный поиск, перебирающий все возможные ходы, и повторяющий один и тот же ход N раз.

### Случайный поиск (`RandomSolver`)
Алгоритм в течении всего допустимого времени на ход генерирует пары `(command, repeat)`, из которых составляются решения. При помощи функции оценки выбирается лучшее. 

Имеет возможность запускаться с эвристикой _сохранения последнего лучшего решения_, изменяет его для поиска новых решений.

### Поиск восхождением (`HillClimbingSolver`)
Поиск восхождением с использованием запоминанием последнего лучшего решения. Для получения первого решения использует `GreedySolver` или `RandomSolver`. Применяет несколько типов мутаций по принципу квот. Для распределения квот все мутаторы использовались одновременно и считалось, в какой доле случаев тот или иной мутатор выигрывал.

#### Мутации:
- Мутация случайного сегмента. Случайно выбирает количество сегментов, на которые нужно разбить решение и количество мутируемых сегментов. Случайно выбирает несколько мутируемых сегментов и случайно меняет в них команды одним из следующих способов:
  1) Заполнение с повторением
  2) Заполнение шумом
  3) Заполнение бездействием
Статистика показала, что каждая из приведенных выше мутаций дает улучшение в 1/3 случаев.
- Мутация переворачивания случайного сегмента. Принимает количество сегментов, на которые нужно разбить решение и количество мутируемых сегментов. Выбранные случайно сегменты переворачиваются.
- Мутация замены двух соседних сегментов. Два случайно выбранных соседних сегмента меняются местами.
Реализована техника использования последнего лучшего решения. Включается, если передать соответствующий флаг.

### Генетический алгоритм (`EvolutionSolver`)
Для получения первого решения (популяции) использует предыдущие алгоритмы или их комбинацию в различных пропорциях (класс `CombinedSolver`).
Для получения следующих решений, популяция проходит через несколько шагов:

1. **Выбираются предки, которые будут изменяться**
   За выбор предков ответственен `IGeneticFilter`. На текущий момент есть две реализации:
   * `HalfFilter` сортирует решения по очкам и выбирает половину лучших решений
   * В `NormalizeFilter` шанс выбора определенного решения равен нормализованному значению очков

2. **Выбранные предки преобразовываются в потомков**
   За это отвечает `IGeneticApplier`. Есть две реализации:
   * `MutationApplier` позволяет использовать любую мутацию, совместимую с `HillClimbingSolver`
   * `SegmentCrossingOver` рассматривает пары предков, разделяет их решения по случайному числу K (на первые K шагов и остальные), берет первую часть от первого предка, вторую - от второго

3. **Из предков и потомков выбирается новая популяция**
   За это отвечает `IGeneticSelector`. Есть две реализации:
   * `Elitism` оставляет одного лучшего предка и выбирает лучших потомков
   * `ElitismRandom` помимо этого добавляет еще одно случайное решение

## Система тестов

В первую очередь мы сгенерировали или написали вручную около 15 тестов. 

Следующим шагом мы провели ряд экспериментов, с помощью которых мы выделили 2 группы тестов (стабльные и нестабильные).

Критерий стабильности оценивался по "выживаемости" алгоритмов на данной карте.

![Система тестов](/Images/maps.png)

## Результаты (beta)

[Промежуточные вычисления](https://docs.google.com/spreadsheets/d/1jnzvyOMs1Fs-sn62Y32mR_D2tlMVwEJQ1C1jdlvhAr8/edit?usp=sharing)

Результаты            | Greedy      | Random      | Hill Climb   | Evolution
----------------------|-------------|-------------|--------------|---------------
**Параметры**         | Глубина: 20<br>Стратегия: Повтор<br>Оценка: Max | Глубина: 11<br>Макс.сегмент: 9 | BaseSolver: `Greedy(15)`<br>Эвристика: `true`<br>BaseSolverTime: 1/10 | BaseSolver: `Greedy(20)`<br>Filter: `FilterHalf`<br>Applier: `SegmentCrossingOver`<br>Selector: `Elitism`
**Score ± ConfInt/2** | 1666 ± 24.2 |   1630 ± 47,5     | 1474 ± 18.2  | 1553 ± 39.3
